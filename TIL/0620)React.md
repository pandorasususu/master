# 2022.06.15

코드잇 - React 프론트엔드 개발 - React로 데이터 다루기 39강/81강

```
useEffect
vue의 life cycle hook과 비슷한 역할을 하는 것 같다. 페이지가 최초로 렌더링 될 때만 콜백함수를 실행해 무한루프에 빠지는 것으로부터 방지한다. 

react는 useEffect함수의 콜백함수와 dependency list를 기억하고, 최초 렌더링 후 콜백함수를 실행하고, 그 이후 렌더링 부터는 dependency list가 변경될 때마다 콜백함수를 실행
```



```
페이지네이션 = 많은 양의 데이터를 불러올 때 특정 기준에 의해 나누어 불러오는 것
오프셋 기반은 받아온 개수를 기준으로 데이터를 나누어, 데이터가 추가/삭제됨에 따라 원하는 페이지를 불러오는 것이 어려움
커서 기반은 특정 데이터를 가리키는 커서값을 통해 데이터의 변경과 무관하게 원하는 페이지를 불러올 수 있음
```



```
조건부 렌더링
ex) 
{Value && <h1>Value</h1>}
만약 Value의 값이 false라면 뒤의 h1 tag는 렌더링 되지 않는다.
{Value ? <h1>Value</h1> : <h1>No Value</h1>}
위와 같이 삼항 연산자를 사용할 수도 있다.

주의점: 숫자 0은 0으로 렌더링 된다.
```



```
비동기 상황에서 state를 변경할 때 이전 state 값을 사용하려면 setter함수에서 콜백을 사용해서 이전 state 값을 사용해야 됨

try catch finally를 활용해 에러 출력

이제 관리해야 할 state 수가 너무 많아서 하나의 파일로 관리하기 어렵다. 빨리 vuex 같은 기능을 배워서 깔끔하게 정리하고 싶다...

사용자가 input에 입력할 때마다 html에서는 oninput prop이 발생, 리액트에서는 onChange가  발생
```



```
setValues((preValues) => ({
      ...preValues,

[name]: value,

}));

setValues((preValues) => {
   return {
      ...preValues,
      [name]: value,
   };
});

위 두 코드는 같은 기능을 한다.

첫번째 코드에서 => 이후 부분을 소괄호로 감싸준 이유는 리턴값이 객체형일 경우 함수와 구분이 안되기 때문이다.
```



```
제어 컴포넌트: 인풋의  value 값을 리액트에서 지정하기 때문에 리액트에서 사용하는 값과 실제 인풋값이 항상 일치, 주로 권장되는 방법
비제어 컴포넌트: 인풋의 value값을 리액트에서 지정하지 않음, 경우에 따라 사용(파일 인풋은 value prop을 지정할 수 없고 반드시 비제어 컴포넌트로 만들어야 함 <= 보안 문제 때문에 파일 인풋은 html에서 사용자만 값을 바꿀 수 있음)
```



```
파일인풋에서 밸류는 파일 이름을 받는데, js로는 빈 문자열로밖에 설정할 수 없다
해커가 자바스크립트로 내 컴퓨터 파일을 몰래 전송하면 안되니깐 보안문제 때문에 html에서 파일 인풋은 반드시 사용자만 값을 바꿀 수 있음. 자바스크립트로는 값을 바꿀 수 없음
```



```
useRef 통해 실제 DOM노드를 직접 참조할 수 있음
주의: DOM노드는 렌더링이 끝나고 생김, ref 객체의 current값도 화면에 컴포넌트가 렌더링됐을 때 존재
=> 항상 inputRef.current값이 존재하는지 확인해야?
```



```
object url을 만들면 웹브라우저는 메모리를 할당하고 파일에 해당하는 주소를 만들어줌
이처럼 컴포넌트 함수에서 외부의 상태를 바꾸는 것 => side effect
ex) fetch같은 network request, 메모리 할당
side effect 다룰 때 주로 useEffect 사용
=> 컴포넌트 안에 데이터와 리액트 바깥에 있는 데이터를 일치시키는 '동기화' 작업에 useEffect가 유용
```



```
정리함수 Cleanup Function
useEffect(() => {
  // 사이드 이펙트

  return () => {
    // 사이드 이펙트에 대한 정리
  }
}, [dep1, dep2, dep3, ...]);
새로운 콜백 함수가 호출되기 전에 실행되거나 (앞에서 실행한 콜백의 사이드 이펙트를 정리), 컴포넌트가 화면에서 사라지기 전에 실행 (맨 마지막으로 실행한 콜백의 사이드 이펙트를 정리).
```



